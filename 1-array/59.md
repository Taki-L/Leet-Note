# [59. Spiral Matrix II](https://leetcode-cn.com/problems/spiral-matrix-ii/)
Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.

Â 

**Example 1:**

![spiraln](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```c++
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
```
**Example 2:**
```c++
Input: n = 1
Output: [[1]]
```

**Constraints:**

1 <= n <= 20

# Solution1

Here is a failed solution by myself, the central idea is to build a loop, like [left,right), and then draw the circle, at the end of it,  judge if it's a input of odd number, if it is, need to add the last number in the center of the matrix.

This solution can only deal with n=3, if n=4 or bigger, it will failed because it can only filled the outermost numbers.

So I record the solution of this failure, and I will come back to correct it when there is a better solution later.

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector< vector<int> > nums(n, vector<int>(n, 0));
        int len = n-1;
        int Index = 1;
        int row = 0;
        int col = 0;
        int count = 0;
        while(len>1){
            switch (Index){
                case 1:
                    for(int i = row; i < len; i++){
                        nums[0][i] = i - row + 1 + count * (n-1);
                    }
                    count++;
                    Index++;
                    break;
                case 2:
                    for(int j = col; j < len; j++){
                        nums[j][len] = j - col + 1 + count * (n-1);
                    }
                    count++;
                    Index++;
                    break;
                case 3:
                    for(int i = len; i > row; i--){
                        nums[len-row][i] = (len-i) + 1 + count * (n-1);
                    }
                    count++;
                    Index++;
                    break;
                case 4:
                    for(int j = len; j > col; j--){
                        nums[j][col] = (len-j) + 1 + count * (n-1);
                    }
                    count++;
                    Index=1;
                    row++;
                    col++;
                    len -= 1;
                    break;
            }

        }
        if(n%2==1){
            nums[n/2][n/2] = n*n;
        }
        return nums;
    }
};
```

# Solution2

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector< vector<int> > nums(n, vector<int>(n, 0));
        int x = 0, y = 0;
        int startx = 0, starty = 0;
        int loop = n / 2;
        int count = 1;
        int offset = 1;
        int i,j;
        while(loop--){
            for(j = starty; j < starty + n - offset; j++)   nums[starty][j] = count++;
            for(i = startx; i < startx + n - offset; i++)   nums[i][j] = count++;
            for(; j > starty; j--)  nums[i][j] = count++;
            for(; i > startx; i--)  nums[i][j] = count++;
            startx++;
            starty++;
            offset+=2;
        }

        if(n%2==1) nums[n/2][n/2] = n*n;
        return nums;
    }
};
```

# Note
Here is a ingenious solution, it take full advantage of the relationship between each code and the next.

Like those four for cycles, they fully connected by the "count++", and the every "while" loop is connected by "startx" and "starty", by the way, its clever to use a offset variant to limit the start position instead of using many "if" judgement.
