# Questions

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

Example 4:

Input: nums = [1,3,5,6], target = 0
Output: 0

Example 5:

Input: nums = [1], target = 0
Output: 0

## idea

1.  before the whole array
2.  equal one element the array
3.  insert the array
4.  after the whole array

# Solution1-Violent_1

    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) {
            int len = nums.size();
            for(int i = 0; i<len;i++)
            {
                if(nums[len-1]<target) return len;
                if(nums[i] == target) return i;
                if((nums[i] <target)&&(nums[i+1]>target)) return (i+1);
            }
            return 0;
        }
    };

# Solution2-Violent_2

    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) {
            int len = nums.size();
            for(int i = 0; i<len;i++)
            {
                if (nums[i] >= target) {
                    return i;
                }
            }
            return nums.size();
        }
    };

## Note1:

Get the number of vector、array、string

    //Vector:
    Vector.size()
    //String
    String.size()
    //array
    sizeof(array)/sizeof(array[0])


# Solution3-Dichotomy_1

    //[Left,Right]
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) {
            //dichotomy
            int len = nums.size();
            int left = 0;
            int right = len-1;
            int middle = (left+right)/2;
            while(left <= right)
            {
                middle = (left+right)/2;
                if(nums[middle]>target){
                    right = middle-1;
                }
                if(nums[middle]<target){
                    left = middle+1;
                }
                if(nums[middle]==target) return middle;
            }
            return right + 1;
        }
    };

# Solution4-Dichotomy_2

    // [Left,Right)
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) {
            //dichotomy
            int len = nums.size();
            int left = 0;
            int right = len;
            int middle = (left+right)/2;
            while(left < right)
            {
                middle = (left+right)/2;
                if(nums[middle]>target){
                    right = middle;
                }
                if(nums[middle]<target){
                    left = middle+1;
                }
                if(nums[middle]==target) return middle;
            }
            return right;
        }
    };

## Note2:

The key is to determine the loop boundary;
In the process of binary search, keep invariant(Loop invariant);
